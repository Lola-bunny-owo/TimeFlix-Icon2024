# Funzione per identificare gli outliers in una colonna utilizzando lo Z-score
def find_outliers(df, column):
    
    # Elimina valori nulli nella colonna specificata
    df_clean = df.dropna(subset=[column]).copy()  # Usa una copia per evitare SettingWithCopyWarning
    df_clean['z_score'] = zscore(df_clean[column])  # Calcola lo Z-score

    # Filtra i dati per ottenere solo gli outlier
    outliers = df_clean[df_clean['z_score'].abs() > 3][[column, 'z_score', 'title']]
    return outliers 


# Funzione per la gestione degli outliers in  base alla colonna specificata.
# Se la colonna è 'duration_numeric_film', rimuove i film con durata superiore a 210 minuti.
# Se la colonna è 'duration_numeric_shows', rimuove le serie TV con più di 10 stagioni.
# NON CAPISCO PERCHè FILTRA MALEEEEEEEEEEEEEEE
def manage_outliers(dataframe, target_column, film_threshold=250, show_threshold=15):
    """Gestisce gli outliers in base alla colonna specificata."""
    if target_column not in dataframe.columns:
        print(f"Errore: la colonna '{target_column}' non esiste nel DataFrame.")
        return dataframe
    
    initial_row_count = dataframe.shape[0]

    if target_column == 'duration_numeric_film':
        filtered_dataframe = dataframe[dataframe[target_column] <= film_threshold].copy()
    elif target_column == 'duration_numeric_shows':
        filtered_dataframe = dataframe[dataframe[target_column] <= show_threshold].copy()
    else:
        print(f"Colonna '{target_column}' non supportata per la gestione degli outliers.")
        return dataframe
    
    final_row_count = filtered_dataframe.shape[0]
    rows_filtered = initial_row_count - final_row_count
    print(f"Filtrate {rows_filtered} righe dalla colonna '{target_column}'.")

    return filtered_dataframe


'''Identificazione e descrizione degli outliers per duration_numeric_film e duration_numeric_shows  - versione con Z-Score, da
eventualmente eliminare una volta fatta la review.

duration_film_outliers = eda.find_outliers(df, 'duration_numeric_film')
print(f"\nOutliers nella colonna duration_numeric_film:\n", duration_film_outliers)
duration_shows_outliers = eda.find_outliers(df, 'duration_numeric_shows')
print(f"\nOutliers nella colonna duration_numeric_shows:\n", duration_shows_outliers)
'''

'''
film_threshold = df['duration_numeric_film'].quantile(0.99)
show_threshold = df['duration_numeric_shows'].quantile(0.99)

print(f"Soglia per i film (99° percentile): {film_threshold}")
print(f"Soglia per le serie TV (99° percentile): {show_threshold}")

print("Film che verrebbero rimossi:\n", df[df['duration_numeric_film'] > film_threshold][['title', 'duration_numeric_film']])
print("Serie TV che verrebbero rimosse:\n", df[df['duration_numeric_shows'] > show_threshold][['title', 'duration_numeric_shows']])

# Gestione degli outliers usando le soglie calcolate dai percentili
# NON FUNZIONA - verificare manage_outliers
df = eda.manage_outliers(df, 'duration_numeric_film', film_threshold=film_threshold)
df = eda.manage_outliers(df, 'duration_numeric_shows', show_threshold=show_threshold)

# Verifica degli outliers rimanenti dopo la gestione
duration_film_outliers = eda.find_outliers(df, 'duration_numeric_film')
print(f"\nOutliers sui film aggiornati - rimossi i film di durata > {film_threshold} minuti:\n", duration_film_outliers)
duration_shows_outliers = eda.find_outliers(df, 'duration_numeric_shows')
print(f"\nOutliers sulle serie TV aggiornati - rimosse le serie TV con #stagioni > {show_threshold} :\n", duration_shows_outliers)
'''

# Funzione che calcola i valori unici e non nulli per ciascuna colonna specificata, dove:
# - columns è una lista dei nomi delle colonne da analizzare
# - results è un dizionario contenente il numero di valori unici e non nulli per ciascuna colonna
def null_unique_values(df, columns):
    results = {}

    for column in columns:
        # Calcola i valori unici e non nulli per la colonna corrente
        unique_values = df[column].nunique(dropna=True)  # Valori unici ignorando i NaN
        non_null_count = df[column].notna().sum()        # Numero di valori non nulli
        null_count= df[column].isna().sum()

        # Stampa i risultati per la colonna corrente
        print(f"Colonna: {column}")
        print(f" - Valori unici: {unique_values}")
        print(f" - Valori nulli: {null_count}")
        print(f" - Valori non nulli: {non_null_count}")

        # Salva i risultati in un dizionario
        results[column] = {
            'unique_values': unique_values,
            'non_null_count': non_null_count,
            'null_count': null_count,
        }

    return results

----------------
'''
# Creazione dell'interfaccia grafica
root = tk.Tk()
root.title("Netflix Recommendation System")

# Frame per il tipo di contenuto
type_frame = tk.LabelFrame(root, text="Content Type")
type_frame.pack(fill="x", padx=5, pady=5)

content_type_var = tk.StringVar(value="Movie")
ttk.Radiobutton(type_frame, text="Movie", variable=content_type_var, value="Movie").pack(side="left", padx=5)
ttk.Radiobutton(type_frame, text="TV Show", variable=content_type_var, value="TV Show").pack(side="left", padx=5)

# Frame per la durata
duration_frame = tk.LabelFrame(root, text="Duration (Minutes)")
duration_frame.pack(fill="x", padx=5, pady=5)

min_duration_var = tk.IntVar(value=0)
max_duration_var = tk.IntVar(value=200)
tk.Label(duration_frame, text="Min Duration").pack(side="left", padx=5)
tk.Entry(duration_frame, textvariable=min_duration_var, width=5).pack(side="left", padx=5)
tk.Label(duration_frame, text="Max Duration").pack(side="left", padx=5)
tk.Entry(duration_frame, textvariable=max_duration_var, width=5).pack(side="left", padx=5)

# Frame per i generi
genre_frame = tk.LabelFrame(root, text="Genres")
genre_frame.pack(fill="x", padx=5, pady=5)

genres_list = ["Action", "Comedy", "Drama", "Fantasy", "Horror", "Romance", "Sci-Fi", "Thriller"]
genre_var = tk.Listbox(genre_frame, selectmode="multiple", height=6)
for genre in genres_list:
    genre_var.insert(tk.END, genre)
genre_var.pack(fill="x", padx=5, pady=5)

# Frame per il cast
cast_frame = tk.LabelFrame(root, text="Cast (Optional)")
cast_frame.pack(fill="x", padx=5, pady=5)

cast_entry = tk.Entry(cast_frame)
cast_entry.pack(fill="x", padx=5, pady=5)

# Frame per i pulsanti
button_frame = tk.Frame(root)
button_frame.pack(fill="x", padx=5, pady=5)

ttk.Button(button_frame, text="Submit", command=submit_preferences).pack(side="left", padx=5)
ttk.Button(button_frame, text="Reset", command=reset_fields).pack(side="right", padx=5)

# Avvio dell'interfaccia grafica
root.mainloop()
'''

---------------------------------------------------------------------
IMPORTANTE: CODICE PER IL FILTRAGGIO NON FUNZIONANTE, LO METTO QUI PER CAPIRCI QUALCOSA IN PIÙ.

# Funzione che filtra i contenuti in base alle preferenze dell'utente
'''def preferences_filter(df, is_movie, is_show, min_duration, max_duration, selected_genres):
    filtered_results= []
    
    for _, item in df.iterrows():
        genres = item.get("Genre", [])
        
        print(f"Controllo item: {item['Title']}")
        print(f"Genres: {genres}")
        
        if is_movie:
            print(f"Checking if item is a movie...")
            if item.get("Is_Movie", False) and min_duration <= item.get("Films_Duration", 0) <= max_duration:
                print(f"Item matches duration criteria for movies")
                if any(genre in genres for genre in selected_genres):
                    print(f"Item matches genre criteria for movies")
                    filtered_results.append(f"Movie - {item['Title']} - Duration: {item.get('Films_Duration', 'N/A')} - Genres: {', '.join(genres)}")
        elif is_show:
            print(f"Checking if item is a TV show...")
            if item.get("Is_TVShow", False) and min_duration <= item.get("Shows_Duration", 0) <= max_duration:
                print(f"Item matches duration criteria for TV shows")
                if any(genre in genres for genre in selected_genres):
                    print(f"Item matches genre criteria for TV shows")
                    filtered_results.append(f"TV Show - {item['Title']} - Seasons: {item.get('Shows_Duration', 'N/A')} - Genres: {', '.join(genres)}")
    
    return filtered_results'''

# Funzione che filtra i contenuti in base alle preferenze dell'utente -- TO FIX!! NON FUNZIONAAA NON CAPISCO PERCHÉ
def preferences_filter(df, is_movie, is_show, min_duration, max_duration, selected_genres):
    filtered_results = []

    for _, item in df.iterrows():
        # Recupera la colonna "Genre" e assicura che sia una lista
        genres = item.get("Genre", [])
        if isinstance(genres, str):  # Se è una stringa, convertila in lista
            genres = genres.strip("[]").replace('"', '').split(", ")

        print(f"Controllo item: {item.get('Title', 'N/A')}")
        print(f"Genres: {genres}")

        if is_movie:
            print(f"Checking if item is a movie...")
            if item.get("Is_Movie", False) and min_duration <= item.get("Films_Duration", 0) <= max_duration:
                print(f"Item matches duration criteria for movies")
                if any(genre in selected_genres for genre in genres):
                    print(f"Item matches genre criteria for movies")
                    filtered_results.append(f"Movie - {item.get('Title', 'N/A')} - Duration: {item.get('Films_Duration', 'N/A')} - Genres: {', '.join(genres)}")

        elif is_show:
            print(f"Checking if item is a TV show...")
            if item.get("Is_TVShow", False) and min_duration <= item.get("Shows_Duration", 0) <= max_duration:
                print(f"Item matches duration criteria for TV shows")
                if any(genre in selected_genres for genre in genres):
                    print(f"Item matches genre criteria for TV shows")
                    filtered_results.append(f"TV Show - {item.get('Title', 'N/A')} - Seasons: {item.get('Shows_Duration', 'N/A')} - Genres: {', '.join(genres)}")

    return filtered_results
   
---------------------------------------------------------------------
Se servisse fare nuovamente debug per i filtri:

'''
print("\nEcco qui il momento delle stampe prove per capirci qualcosa sul codice: \n")
print(df[['Title', 'Genre_Film', 'Genre_Shows', 'Films_Duration', 'Shows_Duration']])

# Esempio di filtro base per i film
suggerimenti1 = df[
    (df['Films_Duration'] >= 1) & 
    (df['Is_Movie'] == 1) & 
    (df['Genre_Film'].apply(lambda genres: any('Faith & Spirituality' in genre for genre in genres)))
]
suggerimenti1 = suggerimenti1.drop(columns=['ID', 'Director', 'genre_embedding_film', 'genre_embedding_shows'])

print("\nSuggerimenti 1:\n", suggerimenti1.head(5))


# Esempio di filtro base per le serie tv
suggerimenti2 = df[
    (df['Shows_Duration'] >= 1) & 
    (df['Is_TVShow'] == 1) & 
    (df['Genre_Shows'].apply(lambda genres: any('Comedies' in genre for genre in genres)))
]
suggerimenti2 = suggerimenti2.drop(columns=['ID', 'Director', 'genre_embedding_film', 'genre_embedding_shows'])

print("\nSuggerimenti 2:\n", suggerimenti2.head(5))      

# Controlla ogni condizione individualmente
cond1 = df['Films_Duration'] <= 10    # funziona
cond2 = df['Is_Movie'] == 1     # funziona
cond3 = df['Genre_Film'].apply(lambda genres: 'Comedies' in genres)   # funziona

print("Cond1", df[cond1])  # Condizione 1
print("Cond2", df[cond2])  # Condizione 2
print("Cond3", df[cond3])  # Condizione 3
'''
---------------

funzione w2v.. parte degli embeddings medi, se serve cambiare il valore da None a 0.0 (valori nulli)
 # Creazione degli embedding medi per film e serie TV - i valori nulli vengono sostituiti con 0.0
    # df['Genre_Embedding_Film'] = df['Genre_Film'].apply(lambda x: np.nan_to_num(model.wv[x].mean(axis=0), nan=0.0) if x else np.zeros(100))
    # df['Genre_Embedding_Show'] = df['Genre_Show'].apply(lambda x: np.nan_to_num(model.wv[x].mean(axis=0), nan=0.0) if x else np.zeros(100))
    
--------------
main:

PCA, stampa dei valori degli array di embeddings
print("\nEmbeddings per i film convertiti: ", embeddings_array_film[:3]) 

------------------ Filtro che era nel file "interface.py", cambiato con il filtro che applica una tecnica di backtracking + forward checking.

# Funzione che filtra i contenuti in base alle preferenze dell'utente
def preferences_filter(df, Is_movie, Is_TVshow, min_duration, max_duration, selected_genres):
    filtered_results = []

    # Maschera booleana per i generi basata sul tipo di contenuto
    if Is_movie:
        genre_mask = df['Genre_Film'].apply(lambda x: any(genre in selected_genres for genre in x))
        duration_mask = (df['Film_Duration'].fillna(0) >= min_duration) & (df['Film_Duration'].fillna(0) <= max_duration)
        type_mask = df['Is_movie'] == 1
    elif Is_TVshow:
        genre_mask = df['Genre_Show'].apply(lambda x: any(genre in selected_genres for genre in x))
        duration_mask = (df['Show_Duration'].fillna(0) >= min_duration) & (df['Show_Duration'].fillna(0) <= max_duration)
        type_mask = df['Is_TVshow'] == 1
    else:
        return []

    # Filtro finale
    filtered_df = df[genre_mask & duration_mask & type_mask]

    # Creazione della lista di risultati formattati
    for _, item in filtered_df.iterrows():
        if Is_movie:
            filtered_results.append(f"Movie - {item['Title']} - Duration: {item.get('Film_Duration', 'N/A')} - Genres: {', '.join(item.get('Genre_Film', []))}")
        elif Is_TVshow:
            filtered_results.append(f"TV Show - {item['Title']} - Seasons: {item.get('Show_Duration', 'N/A')} - Genres: {', '.join(item.get('Genre_Show', []))}")

    return filtered_results

------------
Vecchia funzione per l'estrazione dei titoli dai suggerimenti

def extract_title_from_recommendation(recommendation):
    # The expected format is "Movie/TV Show - Title - Duration/Seasons - Genres"
    parts = recommendation.split(" - ")
    
    # We expect the second part to be the title
    if len(parts) > 1:
        return parts[1].strip()  # Return the title and remove any extra spaces
    return recommendation  # Fallback to the whole string if it doesn't match the format


---------------- Funzione per generare il dataset fittizio nel file di preprocessing, fase apprendimento probabilistico
# Funzione per generare dati sintetici in un dataset fittizio con preferenze di visione
'''def generate_synthetic_time_pref(n_samples):
    
    # Imposta un seme fisso per il generatore di numeri casuali per ottenere risultati riproducibili
    np.random.seed(42)
    
    # Definisce la lista dei giorni della settimana e una lista di orari a intervalli di un'ora
    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    times = pd.date_range('00:00', '23:59', freq='1h').strftime('%H:%M') 

    data = []
    for _ in range(n_samples): # Per ogni campione sceglie casualmente un giorno ed un orario di inizio
        day = np.random.choice(days)
        start_time = np.random.choice(times)
        
        # Genera un orario di fine che sia almeno 1 ora dopo l'inizio, con una durata casuale tra 1 e 3 ore
        start_minutes = int(start_time.split(':')[0]) * 60 + int(start_time.split(':')[1])
        end_minutes = start_minutes + np.random.randint(60, 180)  
        end_time = f"{end_minutes // 60 % 24:02d}:{end_minutes % 60:02d}"

        # Imposta la preferenza ad 1 se:
        # - il giorno è un fine settimana (Saturday e Sunday) AND l'orario d'inizio è tra le 10:00 e le 23:00
        # - il giorno è un qualunque altro giorno AND l'orario d'inizio è tra le 18:00 e le 22:00
        is_preferred = 1 if ((day in ['Saturday', 'Sunday'] and 10 <= start_minutes // 60 < 23) or
                            (day not in ['Saturday', 'Sunday'] and 18 <= start_minutes // 60 <= 22)) else 0

        # Raccolta di tutti i campioni generati in un dataframe con colonne Day, Start_Time, End_Time e Is_Preferred
        data.append([day, start_time, end_time, is_preferred])  

    return pd.DataFrame(data, columns=['Day', 'Start_Time', 'End_Time', 'Is_Preferred'])'''
