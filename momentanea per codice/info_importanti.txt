Da Chatgpt, info utili sul come procedere:

Raccolta delle Preferenze dell'Utente:
Prima di applicare il modello di raccomandazione e fare lo splitting dei dati, è necessario raccogliere le preferenze dell'utente e strutturarle all'interno di un DataFrame. Questo processo di raccolta permette di personalizzare le raccomandazioni in modo che rispecchino i gusti e i comportamenti dell'utente. La fase di raccolta e gestione delle preferenze può essere considerata una parte avanzata del sistema, soprattutto perché influenzerà direttamente i modelli di raccomandazione e le tecniche di ingegneria della conoscenza che verranno utilizzate.

Quante Preferenze l'Utente dovrebbe Esprimere?
Per ottenere un profilo accurato dell'utente, è consigliabile raccogliere una serie di preferenze che coprano diversi aspetti rilevanti per la raccomandazione. Un buon set di preferenze dovrebbe includere almeno:

Preferenze di Genere: I generi preferiti (es. Commedia, Drammatico, Azione).
Tipo di Contenuto: Preferenza tra serie TV e film.
Durata Preferita: Tempo massimo o ideale di visione (es. meno di 90 minuti per un film, meno di 30 minuti per una serie).
Orario di Visione Preferito: Momento della giornata in cui si preferisce guardare contenuti (es. mattina, pomeriggio, sera).
Giorno della Settimana: Giorni preferiti per la visione (es. weekend, giorni feriali).
Rating Minimo Accettabile: Punteggio minimo dei contenuti (es. evitare contenuti con un rating inferiore a 3 stelle).
Esempio di DataFrame delle Preferenze dell'Utente:
Una volta raccolte, queste preferenze possono essere strutturate in un DataFrame come segue:

import pandas as pd

# Esempio di preferenze utente raccolte
preferences = {
    'genre': ['Comedy', 'Action', 'Sci-Fi'],   # Generi preferiti
    'type': ['Movie', 'TV Show'],              # Tipo di contenuto preferito
    'preferred_duration': [90],                # Durata massima in minuti
    'preferred_time_of_day': ['Evening'],      # Orario preferito per la visione
    'preferred_day_of_week': ['Weekend'],      # Giorni preferiti
    'rating': ['TV-MA', 'TV-16', ...]          # Punteggio minimo accettabile
}

# Creazione del DataFrame delle preferenze
user_preferences_df = pd.DataFrame([preferences])

# Visualizzazione del DataFrame delle preferenze
print(user_preferences_df)


Applicazione delle Tecniche di Ingegneria della Conoscenza:
Questa fase di raccolta delle preferenze, sebbene sembri preliminare, si collega profondamente con tecniche avanzate come:

Constraint Satisfaction Problems (CSP): Definire regole e vincoli basati sulle preferenze dell'utente (es. non raccomandare contenuti oltre una certa durata).
Apprendimento Supervisionato: Utilizzare le preferenze passate e feedback espliciti per allenare modelli che predicono i contenuti preferiti.
Apprendimento Non Supervisionato: Identificare pattern nascosti nelle preferenze dell'utente per scoprire raccomandazioni non ovvie, come raggruppare utenti con gusti simili.
Tecniche di Embedding: Utilizzare Word2Vec o altri metodi di embedding per rappresentare le preferenze in uno spazio numerico, facilitando l'uso di modelli di Machine Learning.

Perché Questa Fase è Avanzata:
La fase di gestione delle preferenze dell'utente e la loro trasformazione in input per il sistema non sono banali e sono strettamente legate all'infrastruttura del sistema di raccomandazione. Le preferenze influenzano direttamente i modelli che verranno utilizzati, rendendo questa parte fondamentale per l’accuratezza e la personalizzazione delle raccomandazioni. Gestire correttamente queste informazioni significa migliorare la capacità del sistema di rispondere in modo efficace alle esigenze dell'utente.

In sintesi, questa raccolta e gestione delle preferenze si posiziona tra la raccolta dei dati e l'applicazione delle tecniche avanzate di machine learning, fungendo da ponte critico per costruire un sistema di raccomandazione solido e user-centric.


---------------------------------------------------
Passi Successivi dopo il Preprocessing:
Dato che il preprocessing è completo e hai identificato le feature chiave nel tuo dataset, il prossimo passo è integrare e strutturare le preferenze degli utenti e applicare le tecniche di ragionamento e apprendimento previste nel progetto. La sequenza e il modo in cui implementerai queste tecniche influenzeranno direttamente la qualità delle raccomandazioni generate dal sistema. Ecco una guida dettagliata sui passi successivi, con una spiegazione su come integrarli al meglio:
1. Raccolta e Gestione delle Preferenze degli Utenti:
La raccolta delle preferenze degli utenti è un passaggio cruciale perché fornirà i parametri base per il sistema di raccomandazione. È importante raccogliere le preferenze per i seguenti aspetti:
Genere (listed_in_clean): Usa embedding come Word2Vec per rappresentare le preferenze sui generi.
Tipo di contenuto (type_Movie, type_TV Show): Preferenza tra film e serie TV.
Durata (duration_numeric_film, duration_numeric_shows): Preferenza sulla durata dei contenuti.
Orario e Giorno della Settimana: Dati esterni che possono essere aggiunti come feature se si desidera considerare i momenti di visione preferiti.
Esempio di Codice per Gestire le Preferenze dell'Utente:
# Creazione di un DataFrame delle preferenze utente
user_preferences = {
    'preferred_genres': ['Comedy', 'Action'],    # Generi preferiti
    'preferred_type': ['Movie'],                # Preferenza per i film
    'max_duration': 120,                        # Durata massima in minuti
    'preferred_time': ['Evening'],              # Orario preferito per la visione
    'preferred_days': ['Weekend'],              # Giorni preferiti
}

# Creazione del DataFrame delle preferenze
user_preferences_df = pd.DataFrame([user_preferences])

# Integrazione delle preferenze con il dataset principale
# Potrebbe essere utile avere un sistema di mappatura delle preferenze dell'utente con il contenuto
print(user_preferences_df)

2. Aggiunta di Feature Potenzialmente Mancanti:
Per integrare al meglio le tecniche di apprendimento e ragionamento, potrebbe essere necessario aggiungere nuove colonne o trasformare esistenti:
Orario e Giorno della Settimana: Se non sono inclusi nel dataset, potresti generare dummy variables per l'orario e il giorno della settimana per simulare le preferenze temporali degli utenti.
Feedback dell'Utente: Raccogli i dati di feedback per apprendimento supervisionato; per esempio, valutazioni che l'utente ha dato a film o serie TV precedentemente guardati.
Flag o Contatori: Per aggiungere feature come il numero di visualizzazioni per genere o tipo di contenuto che può essere usato per il clustering o CSP.
3. Applicazione delle Tecniche di Apprendimento e Ragionamento:
Una volta raccolte le preferenze degli utenti, è possibile integrare le tecniche di ragionamento e apprendimento nel seguente ordine:
a) Ragionamento con Vincoli (CSP):
Obiettivo: Implementare regole e vincoli per filtrare i contenuti che non soddisfano le preferenze dell'utente.
Esempio: Escludere contenuti con durata maggiore di quella specificata o che non rispettano il tipo di contenuto richiesto.

# Filtrare contenuti basati sulle preferenze utilizzando vincoli
filtered_content = df[(df['duration_numeric'] <= user_preferences['max_duration']) & 
                      (df['listed_in_clean'].apply(lambda x: any(genre in x for genre in user_preferences['preferred_genres'])))]

b) Ragionamento Proposizionale:
Obiettivo: Creare regole logiche basate sulle preferenze per raccomandare contenuti.
Esempio: Utilizzare regole logiche che, se una serie TV è preferita e ha un rating superiore a un certo valore, venga suggerita prioritariamente.
c) Apprendimento Non Supervisionato (Clustering):
Obiettivo: Identificare pattern nascosti nel comportamento degli utenti, come cluster di utenti con gusti simili.
Esempio: K-means clustering per raggruppare utenti o contenuti simili.
from sklearn.cluster import KMeans

# Esempio di clustering sui dati delle preferenze utente
features_for_clustering = df[['genre_embedding', 'duration_numeric_film', 'duration_numeric_shows']].values
kmeans = KMeans(n_clusters=3).fit(features_for_clustering)

# Assegna cluster ai contenuti
df['cluster'] = kmeans.labels_

d) Apprendimento Supervisionato:
Obiettivo: Utilizzare dati di feedback per predire quali contenuti piaceranno all'utente.
Esempio: Addestrare un modello di classificazione con feedback dell'utente come target.

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier

# Dividi il dataset in training e test
X = df[['genre_embedding', 'duration_numeric_film', 'type_Movie', 'type_TV Show']]  # Feature selezionate
y = df['user_feedback']  # Supponiamo di avere un feedback raccolto

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Addestramento modello di classificazione
model = RandomForestClassifier()
model.fit(X_train, y_train)

# Predizione su dati di test
predictions = model.predict(X_test)
4. Iterazione e Feedback dell'Utente:
Dopo aver implementato le tecniche, è essenziale raccogliere e analizzare i feedback degli utenti per migliorare il sistema:
Raccogli i rating e commenti per aggiornare modelli e vincoli.
Implementa un ciclo di miglioramento continuo basato sul feedback degli utenti.
Conclusione:
La chiave è integrare le preferenze utente, filtrare e trasformare i dati usando ragionamento e apprendimento automatico. Aggiungere colonne come orario, giorno, e raccolta feedback è essenziale per arricchire il dataset e migliorare l’accuratezza delle raccomandazioni. Prosegui in modo iterativo, raffinando il sistema con i dati e i feedback ottenuti.

----------------------------------------------
Se vogliamo fare il renaming delle colonne:
new_column_names = {
    'show_id': 'ID',
    'type': 'Category',
    'title': 'Title',
    'director': 'Director',
    'cast': 'Cast',
    'date_added': 'Date_Added',
    'release_year': 'Year',
    'rating': 'Rating',
    'duration': 'Duration (min)',
    'listed_in': 'Genre',
    'description': 'Description'
}

movie_df.rename(columns=new_column_names, inplace = True)
-------------------------------------------------
Se vogliamo mappare diverse categorie e non avere la dicitura degli stati uniti:

# Get all ratings in the dataset
all_ratings = df['rating'].value_counts().index.to_list()

print(sorted(all_ratings))
['A', 'G', 'NC-17', 'NR', 'PG', 'PG-13', 'R', 'TV-14', 'TV-G', 'TV-MA', 'TV-PG', 'TV-Y', 'TV-Y7', 'TV-Y7-FV', 'UR']
def get_category(rating):
    """
    Map a rating to its corresponding category.

    This function takes a movie or TV show rating and returns the category 
    to which the rating belongs. The categories are defined in a dictionary 
    where each category maps to a list of ratings. The categories are:
    'kids', 'all', 'adults', and 'teens'.

    Args:
        rating (str): The rating to be categorized. Expected values are:
            - 'G', 'TV-G', 'TV-Y', 'TV-Y7', 'TV-Y7-FV' for 'Kids'
            - 'PG', 'TV-PG' for 'All'
            - 'R', 'NC-17', 'TV-MA', 'UR', 'NR' for 'Adults'
            - 'PG-13', 'TV-14' for 'Teens'

    Returns:
        str: The category name with the first letter capitalized if the rating 
        is found in the dictionary. Returns None if the rating is not found 
        in any category.

    Example:
        >>> get_category('G')
        'Kids'
        >>> get_category('PG-13')
        'Teens'
        >>> get_category('XYZ')
        None
    """
    # Dictionary with categories
    categories = {
        'kids': ['G', 'TV-G', 'TV-Y', 'TV-Y7', 'TV-Y7-FV'],
        'all': ['PG', 'TV-PG'],
        'adults': ['R', 'NC-17', 'TV-MA', 'UR', 'NR'],
        'teens': ['PG-13', 'TV-14']
    }
    for category, ratings in categories.items():
        if rating in ratings:
            return category.capitalize()  # Capitalize the category name
    return None
    
---------------------------------------------------------
1. Approccio Tramite Input da Console:
Puoi utilizzare input() in Python per richiedere informazioni all'utente direttamente dalla console. Questo metodo è semplice e ti permette di testare il funzionamento base senza implementare un'interfaccia complessa.

Esempio di Codice:

def collect_user_preferences():
    """
    Funzione per raccogliere le preferenze dell'utente a runtime tramite input da console.
    """
    # Richiedi all'utente il genere preferito
    genres = input("Inserisci i generi preferiti separati da una virgola (es. Action, Comedy, Drama): ").split(',')

    # Richiedi all'utente il tipo di contenuto preferito
    content_type = input("Preferisci Film o Serie TV? (scrivi 'Movie' o 'TV Show'): ").strip()

    # Richiedi la durata massima preferita
    max_duration = int(input("Inserisci la durata massima preferita in minuti (es. 120): "))

    # Richiedi l'orario preferito di visione
    preferred_time = input("Qual è l'orario preferito per guardare contenuti? (es. Morning, Afternoon, Evening): ").strip()

    # Richiedi i giorni della settimana preferiti per guardare contenuti
    preferred_days = input("Quali giorni della settimana preferisci guardare contenuti? (es. Weekend, Weekdays): ").strip()

    # Creazione del dizionario con le preferenze raccolte
    preferences = {
        'preferred_genres': [genre.strip() for genre in genres],  # Pulizia degli input inseriti
        'preferred_type': content_type,
        'max_duration': max_duration,
        'preferred_time': preferred_time,
        'preferred_days': preferred_days
    }
    
    return preferences

# Chiamata della funzione per raccogliere le preferenze
user_preferences = collect_user_preferences()
print("Preferenze raccolte:", user_preferences)

# Integrazione con il sistema di raccomandazione (esempio di filtro)

# Filtrare il dataset in base alle preferenze raccolte
filtered_df = df[(df['duration_numeric'] <= user_preferences['max_duration']) & 
                 (df['listed_in_clean'].apply(lambda x: any(genre in x for genre in user_preferences['preferred_genres']))) &
                 (df['type_Movie'] if user_preferences['preferred_type'] == 'Movie' else df['type_TV Show'])]

print("Contenuti suggeriti in base alle preferenze:")
print(filtered_df[['title', 'duration_numeric', 'listed_in_clean']])

---------------------------------------------
Ho chiesto più info, dato che stiamo lavorando con le preferenze in input di un solo utente:

Cosa fare se hai solo le preferenze di un utente?
Se hai a disposizione solo le preferenze di un utente (ad esempio, generi preferiti, durata ideale, tipo di contenuto come film o serie TV), puoi comunque costruire un sistema efficace utilizzando i seguenti approcci:

Filtraggio Basato su Regole (Rule-Based Filtering)

Definisci delle regole semplici che filtrano i film o le serie in base ai parametri specifici indicati dall’utente.
Esempio: se l’utente preferisce commedie e ha 90 minuti liberi, mostra contenuti di genere "Comedy" con durata minore o uguale a 90 minuti.

Ragionamento con Vincoli (CSP)

Usa le preferenze dell’utente come vincoli da soddisfare per generare raccomandazioni.
Esempio: se l’utente vuole guardare film lunghi nel weekend, imposta dei vincoli per selezionare film con una durata adeguata e che corrispondano a un orario disponibile.

Apprendimento Supervisionato

Addestra un modello supervisionato sui dati storici di preferenze e interazioni passate, se disponibili, anche solo per un singolo utente.
Utilizza classificatori o regressori per prevedere il grado di gradimento di un contenuto in base alle preferenze espresse.

Apprendimento Non Supervisionato (Clustering)

Raggruppa i film o le serie TV in base alle caratteristiche condivise e suggerisci cluster che potrebbero essere di interesse per l’utente.
Esempio: usando K-means, raggruppa contenuti in cluster come "azione breve", "romantico lungo", ecc., e suggerisci il cluster più adatto.

Implementazione Basata su Preferenze Utente
Per implementare questo approccio, segui questi passi:

Acquisizione Input dell'Utente:

Usa input diretti nel codice per raccogliere preferenze specifiche (es. genere, durata).

python

genere_preferito = input("Inserisci il tuo genere preferito (es. Action, Comedy): ")
durata_massima = int(input("Inserisci la durata massima preferita in minuti: "))
tipo_contenuto = input("Preferisci Film o Serie TV? ")
Filtraggio Basato su Preferenze:

Filtra il dataset in base ai criteri dell’utente:

python

suggerimenti = df[
    (df['listed_in_clean'].str.contains(genere_preferito)) &
    (df['duration_numeric'] <= durata_massima) &
    ((tipo_contenuto == "Film" & df['type_Movie'] == 1) | (tipo_contenuto == "Serie TV" & df['type_TV Show'] == 1))
]

Applicazione di Vincoli (CSP):

Integra le preferenze come vincoli per suggerire contenuti che rispettano i criteri dell’utente.
Output del Sistema:

Restituisci la lista di contenuti filtrati che corrispondono alle preferenze indicate.

python

if suggerimenti.empty:
    print("Non ci sono contenuti che corrispondono esattamente alle tue preferenze.")
else:
    print("Ecco i contenuti suggeriti per te:")
    print(suggerimenti[['title', 'duration_numeric', 'listed_in_clean']])
    
Conclusione
In questo approccio, puoi utilizzare le preferenze dell'utente per fornire raccomandazioni personalizzate anche se non hai un modello content-based complesso. Integrare queste tecniche ti permette di rendere il sistema dinamico, adattivo, e più sofisticato rispetto ai modelli semplici.

------------------------------
Dato che facendo così il sistema genererebbe sempre TUTTI i possibili suggerimenti in base alla sua profilazione, ho pensato di chiedere a ChatGPT come implementare un sistema che chieda anche in input il numero di suggerimenti richiesti e come rendere le cose un po' più dinamiche.

Se vuoi che il sistema generi un numero specifico di suggerimenti in base alla quantità scelta dall'utente (ad esempio, 3, 5 o 20 suggerimenti), devi fare una piccola modifica al codice nella fase di output. Invece di mostrare tutti i risultati filtrati, devi selezionare un sottoinsieme del DataFrame in base alla quantità specificata dall'utente.

Modifica da Applicare
Aggiungi l'input per il numero di suggerimenti desiderati dall'utente:

Inserisci un input per chiedere all’utente quanti suggerimenti vuole ricevere.
Seleziona casualmente o prendendo i primi N risultati:

Se il numero di suggerimenti disponibili è maggiore di quello richiesto, prendi solo il numero richiesto.
Puoi selezionare i suggerimenti casualmente per variare l'output o selezionare semplicemente i primi N.

Esempio Modificato del Codice
Ecco come puoi adattare l'esempio:

python

# Acquisizione delle preferenze dell'utente
genere_preferito = input("Inserisci il tuo genere preferito (es. Action, Comedy): ")
durata_massima = int(input("Inserisci la durata massima preferita in minuti: "))
tipo_contenuto = input("Preferisci Film o Serie TV? ")
numero_suggerimenti = int(input("Quanti suggerimenti desideri? "))

# Filtraggio basato sulle preferenze dell'utente
suggerimenti = df[
    (df['listed_in_clean'].str.contains(genere_preferito, case=False, na=False)) &
    (df['duration_numeric'] <= durata_massima) &
    ((tipo_contenuto == "Film" & df['type_Movie'] == 1) | (tipo_contenuto == "Serie TV" & df['type_TV Show'] == 1))
]

# Controllo se ci sono abbastanza suggerimenti
if suggerimenti.empty:
    print("Non ci sono contenuti che corrispondono esattamente alle tue preferenze.")
else:
    # Seleziona casualmente il numero di suggerimenti richiesti dall'utente, o i primi N se < richiesto
    suggerimenti_da_mostrare = suggerimenti.sample(n=min(numero_suggerimenti, len(suggerimenti)), random_state=1)
    print("Ecco i contenuti suggeriti per te:")
    print(suggerimenti_da_mostrare[['title', 'duration_numeric', 'listed_in_clean']])
    
Spiegazione delle Modifiche
Input per il numero di suggerimenti:

numero_suggerimenti = int(input("Quanti suggerimenti desideri? ")) aggiunge la richiesta all’utente di inserire quanti suggerimenti desidera.
Controllo della quantità disponibile:

min(numero_suggerimenti, len(suggerimenti)) assicura che se l'utente chiede più suggerimenti di quanti siano disponibili, il sistema restituisce solo quelli disponibili, evitando errori.
Selezione casuale:

suggerimenti.sample(n=min(numero_suggerimenti, len(suggerimenti)), random_state=1) seleziona casualmente il numero di suggerimenti richiesti. random_state può essere modificato o rimosso per risultati più casuali.
Output Finale
Se l'utente chiede 5 suggerimenti e ne sono disponibili solo 3, il sistema mostrerà i 3 disponibili.
Se ne sono disponibili 10 e l'utente chiede 5, allora ne verranno mostrati 5 casualmente.
Questa modifica ti permette di rendere il sistema più interattivo e personalizzabile secondo le preferenze specifiche dell'utente, migliorando la sua esperienza con suggerimenti mirati.

---------------------------
Per implementare la funzionalità che evidenzia il giorno pianificato sul calendario in base alle preferenze dell'utente, dobbiamo apportare alcune modifiche al codice:

Aggiungere l'input del giorno della settimana: Estenderemo l'interfaccia per includere una selezione del giorno della settimana in cui l'utente preferisce vedere il film o la serie TV.

Calcolare la data esatta del prossimo giorno della settimana selezionato: Dopo aver acquisito il giorno scelto dall'utente, determineremo la prossima occorrenza di quel giorno nel mese corrente.

Evidenziare il giorno sul calendario: Nella finestra del calendario, il giorno pianificato verrà evidenziato per renderlo visibile all'utente.

Modifiche al Codice
Ecco il codice aggiornato che include questi cambiamenti:

python
Copia codice
import tkinter as tk
from tkinter import ttk, messagebox
import calendar
from datetime import datetime, timedelta
from fpdf import FPDF
import json  # Importa il modulo JSON per salvare le preferenze

# Funzione per salvare le preferenze in un file JSON
def save_preferences(preferences):
    with open("user_preferences.json", "w") as file:
        json.dump(preferences, file)
    messagebox.showinfo("Preferences Saved", "Your preferences have been saved successfully")

# Funzione per calcolare la prossima data del giorno selezionato
def get_next_day_date(day_name):
    today = datetime.now()
    days_ahead = list(calendar.day_name).index(day_name) - today.weekday()
    if days_ahead <= 0:  # Se il giorno è oggi o già passato questa settimana, va alla prossima settimana
        days_ahead += 7
    return today + timedelta(days=days_ahead)

# Funzione per visualizzare i risultati su un calendario
def generate_calendar(results, planned_day):
    planned_date = get_next_day_date(planned_day)
    planned_day_num = planned_date.day
    now = datetime.now()
    cal = calendar.TextCalendar(calendar.SUNDAY)
    cal_str = cal.formatmonth(now.year, now.month)

    # Creazione della finestra del calendario
    top = tk.Toplevel(root)
    top.title("Calendar")
    
    # Highlighting del giorno pianificato
    cal_label = tk.Label(top, text=cal_str, font=("Courier", 10), justify="left")
    cal_label.pack(pady=10)

    # Evidenziamento del giorno pianificato
    calendar_text = cal_str.replace(f"{planned_day_num}", f"[{planned_day_num}]")  # Usa le parentesi per evidenziare il giorno
    cal_highlighted = tk.Label(top, text=calendar_text, font=("Courier", 10), fg="blue")
    cal_highlighted.pack(pady=10)

    result_label = tk.Label(top, text="\n".join(results), justify='left')
    result_label.pack(pady=10)

def generate_pdf(results):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    
    pdf.cell(200, 10, txt="Netflix Recommendations", ln=True, align='C')
    pdf.ln(10)
    
    for result in results:
        pdf.multi_cell(0, 10, result)
        pdf.ln(5)
    
    pdf.output("Netflix_Recommendations.pdf")
    messagebox.showinfo("PDF Generated", "The PDF has been successfully generated")

# Funzione per raccogliere le preferenze dell'utente
def submit_preferences():
    content_type = content_type_var.get()
    min_duration = min_duration_var.get()
    max_duration = max_duration_var.get()
    genres = [genre_var.get(i) for i in genre_var.curselection()]
    cast = cast_entry.get()
    planned_day = day_var.get()

    preferences = {
        "content_type": content_type,
        "min_duration": min_duration,
        "max_duration": max_duration,
        "genres": genres,
        "cast": cast,
        "planned_day": planned_day
    }

    save_preferences(preferences)  # Salva le preferenze in un file

    # Dati di esempio per i risultati
    results = [
        f"{content_type} - Title 1 - 100 min - {', '.join(genres)} - Cast: {cast}",
        f"{content_type} - Title 2 - 120 min - {', '.join(genres)} - Cast: {cast}"
    ]
    
    if len(results) > 0:
        generate_pdf(results)
        generate_calendar(results, planned_day)
    else:
        messagebox.showinfo("No Results", "No results match your preferences.")

# Funzione per resettare i campi
def reset_fields():
    content_type_var.set("Movie")
    min_duration_var.set(0)
    max_duration_var.set(200)
    genre_var.selection_clear(0, tk.END)
    cast_entry.delete(0, tk.END)
    day_var.set(days_of_week[0])

# Creazione dell'interfaccia grafica
root = tk.Tk()
root.title("Netflix Recommendation System")

# Frame per il tipo di contenuto
type_frame = tk.LabelFrame(root, text="Content Type")
type_frame.pack(fill="x", padx=5, pady=5)

content_type_var = tk.StringVar(value="Movie")
ttk.Radiobutton(type_frame, text="Movie", variable=content_type_var, value="Movie").pack(side="left", padx=5)
ttk.Radiobutton(type_frame, text="TV Show", variable=content_type_var, value="TV Show").pack(side="left", padx=5)

# Frame per la durata
duration_frame = tk.LabelFrame(root, text="Duration (Minutes)")
duration_frame.pack(fill="x", padx=5, pady=5)

min_duration_var = tk.IntVar(value=0)
max_duration_var = tk.IntVar(value=200)
tk.Label(duration_frame, text="Min Duration").pack(side="left", padx=5)
tk.Entry(duration_frame, textvariable=min_duration_var, width=5).pack(side="left", padx=5)
tk.Label(duration_frame, text="Max Duration").pack(side="left", padx=5)
tk.Entry(duration_frame, textvariable=max_duration_var, width=5).pack(side="left", padx=5)

# Frame per i generi
genre_frame = tk.LabelFrame(root, text="Genres")
genre_frame.pack(fill="x", padx=5, pady=5)

genres_list = ["Action", "Comedy", "Drama", "Fantasy", "Horror", "Romance", "Sci-Fi", "Thriller"]
genre_var = tk.Listbox(genre_frame, selectmode="multiple", height=6)
for genre in genres_list:
    genre_var.insert(tk.END, genre)
genre_var.pack(fill="x", padx=5, pady=5)

# Frame per il cast
cast_frame = tk.LabelFrame(root, text="Cast (Optional)")
cast_frame.pack(fill="x", padx=5, pady=5)

cast_entry = tk.Entry(cast_frame)
cast_entry.pack(fill="x", padx=5, pady=5)

# Frame per la selezione del giorno
day_frame = tk.LabelFrame(root, text="Preferred Day")
day_frame.pack(fill="x", padx=5, pady=5)

days_of_week = list(calendar.day_name)
day_var = tk.StringVar(value=days_of_week[0])
ttk.Combobox(day_frame, textvariable=day_var, values=days_of_week).pack(fill="x", padx=5, pady=5)

# Frame per i pulsanti
button_frame = tk.Frame(root)
button_frame.pack(fill="x", padx=5, pady=5)

ttk.Button(button_frame, text="Submit", command=submit_preferences).pack(side="left", padx=5)
ttk.Button(button_frame, text="Reset", command=reset_fields).pack(side="right", padx=5)

# Avvio dell'interfaccia grafica
root.mainloop()
Spiegazione delle Modifiche:
Selezione del giorno della settimana: È stato aggiunto un Combobox che permette all'utente di selezionare il giorno preferito per la visione. Questa selezione è gestita tramite day_var, una variabile di tipo StringVar.

Calcolo della data pianificata: La funzione get_next_day_date(day_name) calcola la prossima occorrenza del giorno della settimana scelto, partendo dalla data odierna.

Evidenziazione sul calendario: La funzione generate_calendar() evidenzia il giorno pianificato all'interno della visualizzazione del calendario, sottolineando o mettendo tra parentesi il giorno selezionato.

Questo codice permette di pianificare visivamente la visione dei contenuti suggeriti, rendendo l'esperienza utente più intuitiva e interattiva.
